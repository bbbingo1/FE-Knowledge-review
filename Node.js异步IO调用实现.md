> 面试三个问题：
>
> - Node.js 与底层之间是如何执行异步I/O 调用的？和事件循环怎么联系上的呢？
> - 为什么说 Node 高性能，Node 的异步I/O 对高性能助力了什么？
> - Node 的事件循环，你对事件怎么理解？

# 概念回顾

## Node.js 模块分类

- **核心模块（`native`模块）**：**包含在 Node.js 源码**中，被编译进 Node.js 可执行二进制文件JavaScript模块。（lib和deps目录下的js文件，如常用的http、fs等等）

- **内建模块（`built-in`模块）**：一般我们不直接调用，而是在 `native` 模块中调用，再 `require`。（比如 Node 源码lib目录下的 fs.js 就是 native 模块，而fs.js调用的 src 目录下的 node_fs.cc 就是内建模块。）

- **第三方模块**：非 Node.js 源码自带的模块都成为第三方模块，如 express ，webpack 等等（简单理解为开发中需要另外 npm install 的模块）
  - JavaScript模块，最常见
  - JSON模块，就是 JSON 文件
  - C/C++ 扩展模块，使用 C/C++ 编写，编译后后缀名为 .node

## libuv 

 libuv 是一个**高性能的，事件驱动的异步 I/O 库**，由C语言编写的，具有很高的可移植性。libuv 封装了**不同平台底层对于异步IO模型的实现**，libuv 的API 包含有**时间、非阻塞的网络，异步文件操作，子进程**等等，所以它本身还具备Windows、Linux都可使用的跨平台能力。

![](D:\my nutcloud\我的坚果云\note\img\libuv.webp)

## IOCP

概念：输入输出完成端口（Input/Output Completion Port，IOCP），是**支持多个同时发生的异步I/O操作的应用程序编程接口**。

Windows 下注意通过 IOCP 来向系统内核发送 I/O 调用和从内核获取已完成的 I/O 操作，配以**事件循环**，完成异步I/O 的过程。再 linux 下通过 epoll 实现这个过程，也就是由 libuv 自行实现。

IOCP 的另一个应用场景于 `Mater` 和 `app worker`  进程通信使用。

## 线程池

线程池，是一种线程的使用模式，它为了**降低线程使用中频繁的创建和销毁所带来的资源消耗与代价**。通过创建一定数量的线程，让他们时刻准备就绪等待新任务的到达，而任务执行结束之后再重新回来继续待命。

这就是线程池最核心的设计思路，【**复用线程，平摊线程的创建与销毁的开销代价**】。

在 Node 中，无论是 *nix 还是 Window 平台。内部完成 I/O 任务的都有用到线程池。

libuv 目前使用了一个全局的线程池，所有的循环都可以往其中加入任务。
目前有三种操作会在这个线程池中执行：

- 文件系统操作
- DNS 函数（`getaddrinfo` 和`getnameinfo`）
- 通过 `uv_queue_work()` 添加的用户代码

# Node与底层之间的异步I/O调用过程

> **在Node.js 中经典的代码调用方式为：从JavaScript中调用核心模块，再由核心模块调用 C++ 内建模块，内建模块通过libuv 进行系统调用。** 

举例说明：

对比两个经典的api代码：`server.listen` `fs.open` 分别为网络I/O代表和文件I/O代表

结合上图libuv架构（libuv 对 Network I/O和 File I/O 采用不同的机制。）

![](D:\my nutcloud\我的坚果云\note\img\node异步io.webp)

上图展示了libuv细节的流程，先分为两部分：

1. `server.listen()`用于创建TCP server时指定服务器工作的端口和回调函数
2. `fs.open`用于异步打开文件

右图分为两部分：

1. 上半部分为主线程：node 启动时执行。node 启动时完成一系列的初始化，启动v8 engine，进入下一个循环。
2. 下半部分线程池：线程池的数量可以通过环境变量 `UV_THEREADPOOL_SIZE`配置，最大不超过128个，默认为4个。

那么，这样的异步I/O任务与事件循环之间的关系？

## 底层调用与事件产生

我们知道，不管是`server.listen`还是`fs.open`，在开启一个node 服务（进程）的时候，Node 会创建一个`while(true)`的事件循环。每执行一次循环体的过程称为一次Tick。每个Tick其实就是**查看是否有事件待处理**，有，就取出事件。若有关联事件的回调函数就执行。然后进入下一次Tick（循环），直到没有事件处理，退出进程。

那么，事件如何产生并进入Tick？Tick如何知道是否有事件待处理？

### File I/O

结合上图，该I/O执行前后，先是 JavaScript 代码，然后调用`lib/fs.js` 核心模块代码 `fs.open` ，核心模块调用 C++ 内建模块 `src/node_file.cc`，内建模块c++代码会有一个平台判断，然后通过 `libuv` 进行系统调用。（**I/O操作的前戏**）

这里关键出来了：从前面到达 libuv ，会有一个参数，也就是前面整个流程传递进来的**请求对象**，它保存了所有状态，包括送入线程池等待执行以及I/O操作完毕后的回调处理。（**请求对象的作用**）

请求对象组装完成后，送入 libuv 中创建的 I/O 线程池，线程池中的 I/O 操作完毕后，会将获取到的结果存储到 `req -> result` 属性上，然后通过某函数通知 **IOCP** ，告知当前对象操作已经完成，即可以进入事件循环。（**I/O完成通知IOCP**）

在整个过程中，进程初期创建的事件循环中有一个 **I/O 观察者**，每次 Tick 执行，它都会调用 IOCP 相关方法检查线程池中是否有执行完成的请求，如果存在，会将请求对象和之前绑定的 result 属性，加入到 I/O 观察者的队列中，然后将其当做事件处理。（**I/O观察者通过IOCP找事件来处理，即进队列操作**）

来到这里，前面的问题已经解决：
事件如何产生：I/O完成的过程就伴随着事件的产生
事件如何进入Tick：I/O完成后通知IOCP，I/O观察者调用IOCP的方法找到事件并将其当做事件处理，即进入到Tick
Tick如何知道是否有事件待处理：上面一行已经解答：IOCP的功劳

配上一张图，一目了然：

![](D:\my nutcloud\我的坚果云\note\img\node事件循环.webp)

#### Network I/O

V8 engine 执行从 `server.listen()` 开始，调用 `builtin module Tcp_wrap` 的过程。

在创建TCP链接的过程中，libuv直接参与`Tcp_wrap.cc`函数中的 `TCPWrap::listen()` 调用uv_listen()开始到执行`uv_io_start()`结束。看起来很短暂的过程，其实是类似linux kernel的中断处理机制。

`uv_io_start()`负载将 handle 插入到处理的`water queue`中。这样的好处是请求能够立即得到处理。中断处理机制里面的下半部分与数据处理操作相似，交由主线程去完成处理。

![](D:\my nutcloud\我的坚果云\note\img\network IO.png)

> **★**重要：虽然 libuv 的异步文件 I/O 操作是通过线程池实现的，但是网络 I/O 总是在单线程中执行的，注意最后还是会把完成的内容作为事件加入事件循环，事件循环就和文件I/O相同了。

# 异步 I/O 助力 Node.js 高性能

传统的服务器模型

- 同步式: 同步的服务，一次只能处理一个请求，并且其余请求都处于等待状态。
- 每进程/每请求: 为每个请求启动一个进程，这样可以处理多个请求，但是不具有扩展性，系统资源有限，开启太多进程不太合适
- 每线程/每请求: 为每个请求启动一个线程来处理。尽管线程比进程轻量，但是每个线程也都会占用一定内存，当大并发请求的时候，也会占用很大内存，导致服务器缓慢。

**Node就不一样了！**

看了文章前面的内容，Node 通过事件驱动的方式处理请求，无需为每个请求创建额外的对应线程，可以省掉**创建线程和销毁线程**的开销，同时操作系统在调度任务时因为线程较少，**上下文切换**的代价很低。这也是 Node.js 高性能之一

> 参考学习：
>
>《深入浅出NodeJS》
> https://mp.weixin.qq.com/s/5laPdNInHr5eOTzKrfhOxA