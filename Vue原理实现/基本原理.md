### 1.v-if和v-show的区别

当条件不成立时，`v-if`不会渲染DOM元素，`v-show`操作的是样式(display)，切换当前DOM的显示和隐藏。



### 2.Computed和Watch

`Computed`：

1. **具备缓存**
2. **依赖的属性发生变化就会更新视图**
3.  **适用于计算比较消耗性能**的计算场景

`Watch`:

1. **没有缓存**
2. **可以监听某些数据执行回调**
3. 深度监听对象中的属性时，可以打开`deep：true`选项。这样会带来性能问题，**优化的话可以使用`字符串形式`监听**，如果没有写到组件中，不要忘记使用`unWatch手动注销`哦。



### 3.v-model的原理

`v-model`本质就是一个语法糖，可以看成是`value + input`方法的语法糖。 可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。



### 4.keep-alive

`keep-alive`可以实现组件缓存，当组件切换时不会对当前组件进行卸载。

常用的两个属性`include/exclude`，允许组件有条件的进行缓存。

两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态。

keep-alive的中还运用了`LRU(Least Recently Used)`算法。



### 5.SSR

SSR也就是服务端渲染，`也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端`。

SSR有着**更好的SEO**、并且**首屏加载速度更快**等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，**服务器端渲染只支持`beforeCreate`和`created`两个钩子**，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是**服务器会有更大的负载需求**。



### 6.既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?

通常一个**绑定一个数据就需要一个Watcher**,一旦我们的**绑定细粒度过高就会产生大量的Watcher**,这会带来内存以及依赖追踪的开销,而**细粒度过低**会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,**在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的**



### 7.route和router的区别

route是路由信息对象，包括path，name，params，query，hash，fullPath，matched等路由信息参数。
而router是“路由实例”对象包括了路由的跳转方法，钩子函数等。



### 8.怎么定义 vue-router 的动态路由? 怎么获取传过来的值

在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。



### 9.vue3.0的改进

- 更小
  - 从面向对象到function-base（函数式编程），提倡组合大于继承（JS的优势），
  - **tree-shaking，按需引入**。而vue2.x只有一个vue实例，很多注册到全局的东西即使不需要也没办法扔掉。
- 更快
  - **修改了虚拟dom的算法：从之前的每次更新都要进行一次完整的遍历对比，改为了切分区块树，进行动态更新。只diff（对比）有变化的层，6倍速度。**
  - proxy对于JS引擎更加友好，响应更高效
- **typescript**
- Api一致性（留了一个兼容版本作为过渡）
- 提高可维护能力
- **开放更多底层功能**