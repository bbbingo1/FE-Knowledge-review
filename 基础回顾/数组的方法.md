## 创建一个数组

### 常规创建：

```js
// 字面量
var a = [1,2,3];

// 构造器; es5语法中 new可加可不加
var a = array(3); // [,,]
var a = new array(); // []
var a = new array(3,11,8); // [3,11,8]
```

### ES6 Array.of()返回所有参数值组成的数组

Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。

```js
let a = Array.of(3, 11, 8); // [3,11,8]
let a = Array.of(3); // [3]
```

### ES6 Arrary.from() 将类数组对象转为真正的数组

```js
// 1. 对象拥有length属性
let obj = {0: 'a', 1: 'b', 2:'c', length: 3};
let arr = Array.from(obj); // ['a','b','c'];
// 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象
let arr = Array.from('hello'); // ['h','e','l','l','o']
let arr = Array.from(new Set(['a','b'])); // ['a','b']
```

**还可以接受第二个参数，作用类似于数组的`map`方法，这也意味着，只要有一个原始的数据结构，就可以先对它的值进行处理，然后转成规范的数组结构，进而可以使用数量众多的数组方法。**

## 改变原数组的方法

### splice() 添加/删除数组元素

n个参数，第一个表示添加/删除的起始位置（负值如-1表示倒数第一个元素），第二个表示删除的元素个数，第三个往后表示添加的新元素

返回值: 如果有元素被删除,返回包含被删除项目的新数组。

```js
let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0, 3); // [1,2,3]
console.log(a); // [4,5,6,7]
// 从数组下标0开始，删除3个元素
let item = a.splice(-1, 3); // [7]
// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7
```

### sort() 数组排序

默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用`toString()`方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。

```js
let a = [23,45,24,11,2,4,1,7];
a.sort(); // [1, 11, 2, 23, 24, 4, 45, 7]
a.sort((a,b) => a-b); // [1, 2, 4, 7, 11, 23, 24, 45]
a; // [1, 2, 4, 7, 11, 23, 24, 45]
```

底层：数目<=10插入；数目 >10快排

> https://segmentfault.com/a/1190000010648740

### pop() 删除一个数组中的最后的一个元素

### shift() 删除数组的第一个元素

### push() 向数组的末尾添加元素

### unshift() 向数组的开头添加元素

### reverse() 颠倒数组中元素的顺序

### ES6: copyWithin() 指定位置的成员复制到其他位置

参数:

三个参数都是数值，如果不是，会自动转为数值.

1. target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
2. start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
3. end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。

**读了几个元素就从开始被替换的地方替换几个元素**

```js
// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]
[1, 2, 3, 4, 5].copyWithin(0, -2)
// [4, 5, 3, 4, 5]
var a=['OB1','Koro1','OB2','Koro2','OB3','Koro3','OB4','Koro4','OB5','Koro5']
// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换
a.copyWithin(2,3,5)
// ["OB1","Koro1","Koro2","OB3","OB3","Koro3","OB4","Koro4","OB5","Koro5"] 
```

### ES6: fill() 填充数组

参数:

第一个元素(必须): 要填充数组的值

第二个元素(可选): 填充的开始位置,默认值为0

第三个元素(可选)：填充的结束位置，默认是为`this.length`

```js
['a', 'b', 'c'].fill(7)
// [7, 7, 7]
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
```

## 不改变原数组的犯法

### slice() 浅拷贝数组的元素

参数:

begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。

end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。

```js
let a = [1,2,3]
let b = a.slice(1,2); // [2]
console.log(a,b); // [1,2,3] [2]
b[0] = 1;
console.log(a); //[1,2,3]  浅拷贝基本类型不会被影响

let a= [{name:'OBKoro1'}];
let b=a.slice();
console.log(b,a); // [{"name":"OBKoro1"}]  [{"name":"OBKoro1"}]
// a[0].name='改变原数组';
// console.log(b,a); // [{"name":"改变原数组"}] [{"name":"改变原数组"}]
// b[0].name='改变拷贝数组',b[0].koro='改变拷贝数组';
//  [{"name":"改变拷贝数组","koro":"改变拷贝数组"}] [{"name":"改变拷贝数组","koro":"改变拷贝数组"}]
```

### join() 数组转字符串

str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。

```js
let a= ['hello','world'];
let str=a.join(); // 'hello,world'
let str2=a.join('+'); // 'hello+world'
```

使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？

```js
let a= [['OBKoro1','23'],'test'];
let str1=a.join(); // OBKoro1,23,test
let b= [{name:'OBKoro1',age:'23'},'test'];
let str2 = b.join(); // [object Object],test
// 对象转字符串推荐JSON.stringify(obj);
```

所以，`join()/toString()`方法在数组元素是数组的时候，会将里面的数组也调用`join()/toString()`,如果是对象的话，对象会被转为`[object Object]`字符串。

### toLocaleString() 数组转字符串

定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。

无参数

### toString() 数组转字符串 不推荐

### cancat

定义： 方法用于合并两个或多个数组，返回一个新数组。

es6 扩展运算符可以实现同样效果：

```js
let a = [2, 3, 4, 5]
let b = [ 4,...a, 4, 4]
console.log(a,b); //  [2, 3, 4, 5] [4,2,3,4,5,4,4]

let a = [1,2,3]
a.concat(a); // [1, 2, 3, 1, 2, 3]
a; // [1,2,3]
```

### indexOf() 查找数组是否存在某个元素，返回下标

定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。

语法:

```js
array.indexOf(searchElement,fromIndex)
```

参数:

searchElement(必须):被查找的元素

fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。

严格相等的搜索:

数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等`===`搜索元素，即**数组元素要完全匹配**才能搜索成功。

**注意**：indexOf()不能识别`NaN`

```js
let a=['啦啦',2,4,24,NaN]
console.log(a.indexOf('啦'));  // -1 
console.log(a.indexOf('NaN'));  // -1 
console.log(a.indexOf('啦啦')); // 0
```

### astIndexOf() 查找指定元素在数组中的最后一个位置

定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）

参数:

searchElement(必须): 被查找的元素

fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。

关于fromIndex有三个规则:

1. 正值。如果该值大于或等于数组的长度，则整个数组会被查找。
2. 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)
3. 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。

### ES7 includes() 查找数组是否包含某个元素 返回布尔

searchElement(必须):被查找的元素

fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。

**includes方法是为了弥补indexOf方法的缺陷而出现的:**

1. indexOf方法不能识别`NaN`
2. indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于`-1`，表达不够直观。