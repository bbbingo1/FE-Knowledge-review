# V8垃圾回收机制与内存使用

> JS 语言不像 C/C++, 由程序员自己开辟或者释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深的前端工程师，对于JS内存回收的机制是需要非常清楚, 以便于在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解**JS的闭包特性**、以及**对内存的高效使用**，都有很大的帮助。

## V8 的内存限制

具体来说，每个 V8 引擎实例能占用的计算机的内存，**`在64位系统下约为 1.4GB，32位系统下约为 0.7GB`**。虽然不多但**胜任前端页面中的所有需求**已经绰绰有余。而且V8 引擎实例的生命周期不长，且无论这个 V8 实例占用了多少内存，最终**在关闭页面时内存都会被释放**，小型的 Web 应用几乎没有太多管理的必要。

但是对于后端来说，Node 是基于 V8 构建的，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自有的方式来进行分配和管理的。在这样的内存限制下（服务器端可以通过设置修改默认内存限制），将会导致 Node 无法直接操作大内存对象，比如无法将一个 2GB 的文件读入内存进行字符串分析处理。尽管在服务器端操作大内存也不是常见的需求场景，但有了限制之后，如果在实际应用中不小心触碰到这个界限，会造成进程退出。

既然这样那么 V8 为何限制内存的用量？

我们知道，**对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收**。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。

我们也知道，所有的对象类型的数据在JS中都是通过堆进行空间分配的。当我们构造一个对象进行赋值操作的时候，其实相应的内存已经分配到了堆上。你可以不断的这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。

究其根本，V8 为什么要给它设置内存上限？是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。

首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:

> 以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。

不过，如果你想调整这个内存的限制也不是不行。配置命令如下:

```js
// 这是调整老生代这部分的内存，单位是MB。后面会详细介绍新生代和老生代内存
node --max-old-space-size=2048 xxx.js 
```

或者

```js
// 这是调整新生代这部分的内存，单位是 KB。
node --max-new-space-size=2048 xxx.js
```

## 新生代内存的回收

V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。



![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b6ec3859a65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



根据这两种不同种类的堆内存，V8 采用了不同的回收策略，来根据不同的场景做针对性的优化。

首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB。够小吧，不过也很好理解，新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。

那好了，新生代的垃圾回收是怎么做的呢？

首先将新生代内存空间一分为二:



![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b71923adacb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



其中**From部分表示正在使用的内存，To 是目前闲置的内存**。

当进行垃圾回收时，V8 将From部分的对象检查一遍，如果**是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)**，如果是**非存活对象直接回收**即可。

当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色`对调`，From现在被闲置，To为正在使用，如此循环。

那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？

注意，我刚刚特别说明了，在To内存中按照顺序从头放置的，这是为了应对这样的场景:



![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b73ac9e01cc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



深色的小方块代表存活对象，白色部分表示待分配的内存，由于**堆内存是连续分配**的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做**内存碎片**。刚刚介绍的新生代垃圾回收算法也叫**`Scavenge`算法**。

`Scavenge` 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:



![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7741afdb10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



是不是整齐了许多？这样就大大方便了后续连续空间的分配。

**不过`Scavenge `算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。**

 V8 的堆内存示意图：![img](http://www.yangzicong.com/blog/1476702908516.png) 

## 老生代内存的回收

刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到**老生代内存**中，这种现象就叫**晋升**。

发生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:

- **已经经历过一次 Scavenge 回收。**
- **To（闲置）空间的内存占用超过25%。**

现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用`Scavenge`算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？

那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？

第一步，**进行标记-清除（ `Mark-Sweep` ）**。这个过程在《JavaScript高级程序设计(第三版)》中有过详细的介绍，主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中**使用的变量**以及被**强引用**的变量取消标记，剩下的就是要删除的变量了，在随后的**清除阶段**对其进行空间的回收。

当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？

第二步，**整理内存碎片（` Mark-Compact `）**。V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。

![img](https://user-gold-cdn.xitu.io/2019/11/23/16e96b7a41c8c826?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

 由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。 

**下表为 3 种垃圾回收算法的简单对比：**

| 回收算法         | Mark-Sweep | Mark-Compact | Scavenge           |
| :--------------- | :--------- | :----------- | :----------------- |
| **速度**         | 中等       | 最慢         | 最快               |
| **空间开销**     | 少         | 少（无碎片） | 双倍空间（无碎片） |
| **是否移动对象** | 否         | 是           | 是                 |



## Incremental Marking（增量标记）

为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被成为**“全停顿”**（stop-the-world）。

上文提到，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50毫秒以上，做一次非增量式（后文会介绍）的垃圾回收甚至要1秒以上。

在 V8 的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但 V8 的老生代通常配置得较大，且存活对象较多，全堆垃圾回收的标记、清理、整理等动作造成的停顿就会比较久。

为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，也就是拆分为许多小步，每做完一小步就让 JavaScript 应用逻辑执行一会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。

V8 在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。

V8 后续还引入了延迟清理（lazy sweeping），与增量式整理（incremental compaction），让清理与整理动作也变成增量式的。

## 高效使用内存

了解完垃圾回收机制以后，作为开发者的我们要具备的责任就是如何让垃圾回收机制更高效的工作

### 作用域

提到如何触发垃圾回收机制，第一个要介绍的是作用域。在 JavaScript 中能形成作用域的有**函数调用**、**with** 以及**全局作用域**。

以如下代码为例：

```js
var foo = function() {
    var local = {};
};
```

`foo()`函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短。

在这个示例中，由于对象非常小，将会分配在新生代的 From 空间中。在作用域释放后，局部变量`local`失效，其引用的对象将会在下次垃圾回收时被释放。

以上就是最基本的内存回收过程。

### 变量的主动释放

如果变量是全局变量，由于全局作用域需要知道进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过`delete`操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清理和整理的过程中，会被回收释放。

```js
window.foo = "I am global object";

console.log( global.foo ); // => "I am global object"

delete global.foo;
// 或者重新赋值
global.foo = null; // or undefined

console.log(global.foo); // => null
```

如果在非全局作用域中想主动释放变量引用的对象，也可以通过这样的方式。

虽然`delete`操作和重新赋值具有相同的效果，但是在 V8 中通过`delete`删除对象的属性有可能干扰 V8 的优化，所以**通过赋值方式解除引用会更好**。

### 闭包

```js
var foo = function() {
  var bar = function() {
    var local = "局部变量";
    return function() {
      return local;
    }
  };
  var baz = bar();
  console.log(baz()); // "局部变量"
}
```

一般而言，在`bar()`函数执行完成后，局部变量`local`将会随着作用域的销毁而被回收。但是上例中我们使用了闭包传递局部变量，一旦有变量引用这个闭包函数（上例中是一个匿名函数），这个闭包函数将不会释放，同时也使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。

所以，在正常的 JavaScript 执行中，无法立即回收的内存有**闭包**和**全局变量引用**这两种情况。由于 V8 的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。

## 警惕内存泄露

首先先说一下什么是内存泄露：**当应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象时，就形成了内存泄露。**

在通常的代码编写中，很少会出现内存泄露的情况。但是内存泄露通常产生与无意间，我们较难排查。

通常，造成内存泄露的原因有如下几个：

- 缓存
- 队列消费不及时
- 作用域未释放

### 内存做缓存

我们日常开发时，通常喜欢用对象的键值来缓存内容，但这与严格意义上的缓存又有着区别，后者有着完善的过期策略，而普通对象的键值对并没有。

```js
var cache = {};

var get = function(key) {
    if (cache[key]) {
        return cache[key];
    } else {
        return null;
    }
};

var set = function(key, value) {
    cache[key] = value;
}
```

上面的代码十分容易理解，实际上，只要限定缓存对象的大小，加上完善的过期策略以防止内存无限制地增长，这个形式的对象做缓存是可以一用的。

这里给出一个可能无意识造成内存泄露的场景：`underscore`类库对其`memoize`模块的实现：

```js
_.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
        var key = hasher.apply(this, arguments);
        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
};
```

它的原理是以参数作为键进行缓存，但`memo`对象被保存在内部作用域中，并且通过闭包被外部访问到，每次调用`_.memoize`时被执行的结果都会按参数缓存在`memo`对象中，不会被清除。在执行量大和参数多样性的情况下，会造成内存占用不释放。

*（事实上，这在前端网页这种短时应用场景中不会存在问题，在服务器端则会）*

所以，当我们将内存当成缓存使用时，要做好缓存限制策略以及相应的清除策略， 不能让内存无限制增长。

> 参考：
>
>  https://juejin.im/post/5dd8b3a851882572f56b578f 
>
>  http://www.yangzicong.com/article/6 



最后列一下内存控制的优化清单：

- 在不需要使用某个全局变量时，手动解除引用
- 警惕闭包中是否发生内存泄露（DOM事件绑定、循环绑定DOM回调、闭包引用）
- 在处理完较大数据时手动解除引用，方便垃圾回收。



