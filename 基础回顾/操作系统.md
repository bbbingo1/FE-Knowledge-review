## 区分进程和线程

进程：是CPU资源分配的基本单位；线程：是程序执行（CPU调度）的基本单位

可以把进程比作一个车间，车间里有相应的资源，而线程就好比车间里的工人（一个或多个），可以共享车间里的资源

## 死锁

### 产生原因

1. **竞争不可抢占性资源**
2. **竞争可消耗资源**：当系统中供多个进程共享的资源如打印机，公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。
3. **进程推进顺序不合理**

### 产生的四个必要条件

1. **互斥条件**：一个资源每次只能被一个进程使用
2. **请求与保持条件**：一个进程因请求资源而等待时，不会释放原先已分配的资源
3. **不可抢占条件**：进程获得的资源不可以被强行剥夺
4. **循环等待条件**：若干进程形成一个循环等待资源的关系

只要产生死锁，破坏四个条件的其中一个，就可以解除死锁

### 预防死锁

1. 资源一次性分配（破坏请求与保持条件）
2. 可剥夺资源（破坏资源不被剥夺）
3. 资源有序分配（破坏循环等待条件）

### 避免死锁

银行家算法：分配资源时先评估风险，确保分配给一个进程资源时，该进程能够返回全部占用的资源

> 银行家算法:
>
> 设进程i提出请求Request[j]，则银行家算法按如下规则进行判断。
>
> (1) 如果Request[j]≤Need[i,j]，则转向（2），否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
>
> (2) 如果Request[j]≤Available[j]，则转向（3）；否则表示尚无足够资源，Pi需等待。
>
> (3) 假设进程i的申请已获批准，于是修改系统状态：
>
> Available[j]=Available[j]-Request[i]
>
> Allocation[i,j]=Allocation[i,j]+Request[j]
>
> Need[i,j]=Need[i,j]-Request[j]
>
> (4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。
>
> 安全性算法：
>
> (1) 设置两个工作向量Work=Available；Finish[i]=False
>
> (2) 从进程集合中找到一个满足下述条件的进程，
>
>      Finish [i]=False;
>     
>      Need[i,j]≤Work[j];
>     
>      如找到，执行(3)；否则，执行(4)
>
> (3) 设进程获得资源，可顺利执行，直至完成，从而释放资源。
>
>     Work[j]=Work[j]+Allocation[i,j];
>     
>     Finish[i]=True;
>     
>     go to step 2;
>
> (4) 如所有的进程Finish[i]=true，则表示安全；否则系统不安全。

### 解除死锁

1. 抢占资源：从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态
2. 终止（或撤销）进程：终止一个或多个死进程锁，打破循环环路