## OSI七层模型

- 应用层：执行各种应用程序协议：DNS、SMTP、HTTP、FTP等
- 表示层：数据加密解密，转换翻译，压缩解压缩
- 会话层：不同机器上用户之间建立及管理会话
- 运输层：接收上一层数据，在必要的时候对数据分段、编号（UDP不编号）实现可靠的数据报传输
- 网络层：在不同网段间转发数据包（子网运行，分组传输、路由选择；不负责丢失重传和顺序（可靠传输由运输层实现））
- 数据链路层：物理寻址，同时将原始比特流转变为逻辑传输线路
- 物理层：原始比特流传输

## 计网——TCP/UDP，DNS

### DNS

是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。

### DNS域名解析

这是一个查找IP地址的过程，返回的结果就是对应的IP地址。
**DNS 的作用就是通过域名映射查询到具体的 IP。**

- 客户端（浏览器）和本地DNS之间的查询方式是**递归查询**。
  在该模式下 DNS 服务器接收到客户机请求，必须使用一个**准确的查询结果**回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的结果提交给客户机。

- 本地DNS服务器与根域、子域之间的查询方式是**迭代查询**

  若本地hosts和DNS缓存中都不存在一个域名的对应关系，则会去远程不同节点的DNS服务器检索，直到查到该域名匹配的IP。每次迭代都会更接近结果，它是一个收敛的过程。

![img](https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/3.1.dns_inquery.png?raw=true)

### DNS缓存优化

**1、减少DNS查找，避免重定向：**
 **（1）使用浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存，防止DNS迭代查询；
 （2）使用Keep-Alive特性 来减少DNS查找的频率；
 （3）使用较少的域名（服务器主机）来减少DNS查找的数量。**
**2、DNS的预解析**
可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析

```xml
 <meta http-equiv="x-dns-prefetch-control" content="on" />
```

可以使用link标签来强制对DNS做预解析:

```xml
 <link rel="dns-prefetch" href="http://ke.qq.com/" />
```

### 在浏览器地址栏键入url，按下回车会经历：

1. 浏览器向DNS服务器请求解析URL中的域名对应的IP地址
2. 与IP地址对应的服务端建立TCP连接（三次握手)
3. 浏览器发送读取文件请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器
4. 服务器做出响应，并把对应的html文本发送给浏览器
5. 释放TCP连接（四次挥手）
6. 浏览器将html文本解析渲染

### 三次握手四次挥手

#### 三次握手：

第一次（SYN=1，seq=x）：客户端发送一个数据包，syn=1表示请求与服务器建立连接，seq=x表示建立连接的序号为x

第二次（SYN=1，seq=y，ACK=1，ack=x+1）：服务器收到数据报，此时服务器知道可以接收到客户端发送的请求，并返回确认标志ACK=1，ack为确认连接的序号，表示已经收到连接请求；同时发送SYN=1及自己的序号seq=y表示愿意与客户端建立连接

第三次（ACK=1，ack=y+1，seq=x+1）：客户端受到包，发送确认标志及确认序号给服务端，服务端收到后完成连接。

问：前两次握手后客户端受到确认号后不就可以连接了，为啥有第三次握手？
答：避免**由于网络延迟等原因，使得客户端重发数据包**，而**服务端收到后发送了多个包，（对服务器来说）建立了多个连接**（客户端收到一个响应的包后将不会接收后续的相同重复包，但服务端每发出去就等待着该连接下的数据传送）造成资源浪费。
而**有了第三次握手的确认后，服务端就可以知道哪些请求是有效的，不会搭理延迟接收的请求**。

#### 四次挥手

第一次（FIN=1，seq=x）：假设客户端想关闭连接，就发送一个FIN=1的标志表示关闭连接，同时请求序号为seq=x

第二次（ACK=1，ack=x+1）：服务器收到关闭请求，但由于可能还有数据要传送给对方，于是就先发送了一个确认收到关闭请求的包

第三次（FIN=1，seq=y）：服务端准备好关闭连接了，就发送FIN=1及相应序号给客户端

第四次（ACK=1，ack=y+1）：客户端收到服务端的关闭请求，发送一个确认包，等服务端收到后就关闭请求。

问：为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

简单点说就是要等数据传送完，才能关闭，确认ACK和终止FIN要分开发送，TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

### TCP\UDP的区别

| 协议 | 连接性                         | 双工性      | 可靠性                  | 有序性             | 有界性                                                       | 拥塞控制 | 传输速度 | 量级 | 头部大小  |
| ---- | ------------------------------ | ----------- | ----------------------- | ------------------ | ------------------------------------------------------------ | -------- | -------- | ---- | --------- |
| TCP  | 面向连接 (Connection oriented) | 全双工(1:1) | 可靠 (重传机制)         | 有序 (通过SYN排序) | 无, 有[粘包情况](https://www.cxymsg.com/guide/tcp.html#粘包) | 有       | 慢       | 低   | 20~60字节 |
| UDP  | 无连接 (Connection less)       | n:m         | 不可靠 (丢包后数据丢失) | 无序               | 有消息边界, **无粘包**                                       | 无       | 快       | 高   | 8字节     |

### TCP粘包是怎么回事，如何处理? ✨

TCP 连接会启用**延迟传送算法 (Nagle 算法),** 在数据**发送之前缓存**， 如果短时间有**多个数据发送, 会缓冲到一起**作一次发送 , 以**减少 IO 消耗**提高性能.

如果是传输文件的话, 那么根本不用处理粘包的问题, 来一个包拼一个包就好了. 但是如果是多条消息, 或者是别的用途的数据那么就需要处理粘包.

假设连续调用两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下几种常见的情况:

- A. 先接收到 data1, 然后接收到 data2 .
- B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.
- C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.
- D. 一次性接收到了 data1 和 data2 的全部数据.

其中的 BCD 就是常见的粘包的情况. 而对于处理粘包的问题, 常见的解决方案有:

1. 多次发送之前**间隔一个等待时间**：适用于交互频率特别低的场景；但频繁的场景而言传输效率实在太低
2. 关闭 Nagle 算法：适用于每次发送的数据都比较大 (但不是文件那么大), 并且频率不是特别高的场景.
3. **进行封包/拆包**：常用的解决方法；即给每个数据包在发送之前, 于其前/后放一些有特征的数据, 然后收到数据的时候根据特征数据分割出来各个数据包.

### 为什么udp不会粘包？

1. TCP协议是面向流的协议，UDP是面向消息的协议。UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据
2. UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），而接收方一次只能接收独立的一个数据包，所以当接收方接收的数据大小小于UDP发送的数据大小时（即丢失一部分数据），即使丢失，也不愿意分两次接收

## 计网——HTTP部分

### 状态码

**2开头 （请求成功）表示成功处理了请求的状态代码。**

- **200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨**
- 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
- 202 Accepted 请求已接受，但是还没执行，不保证完成请求
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- **206 Partial Content， 服务器成功处理了部分 GET 请求，进行范围请求 ✨**

**3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- **302 found，临时性重定向，表示资源临时被分配了新的 URL ✨**
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源
- **304 not modified，自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容**
- 307 temporary redirect，临时重定向，和302含义相同

> **同样是重定向307，303，302的区别？**
>
> 302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码又出来了两个303和307。
>
> 303明确表示客户端应当采用get方法获取资源，他会把POST请求变为GET请求进行重定向。 307会遵照浏览器标准，不会从post变为get。

**4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。**

- **400 bad request，请求报文存在语法错误 ✨**
- **401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨**
- **403 forbidden，表示对请求资源的访问被服务器拒绝 ✨**
- **404 not found，表示在服务器上没有找到请求的资源 ✨**
- 408 Request timeout, 客户端请求超时
- 409 Confict, 请求的资源可能引起冲突

**5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。**

- **500 internal sever error，表示服务器端在执行请求时发生了错误 ✨**
- 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
- 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本

### http请求方法

- get：请求发送某些资源
- post：发送数据给服务器 
- head：请求资源头部，常用来判断一个大文件的大小而决定是否下载，从而可以节约带宽资源
- options：用于获取目的资源所支持的通信选项
- put：用于新增资源或更新资源
- delete：用于删除资源
- patch：用于对资源进行部分修改
- connect：http/1.1协议中预留给可以将连接改为管道方式的代理服务器
- trace：回显服务器收到的请求，主要用于测试或诊断

### Get和post的区别

- 数据传输方式不同；get请求通过url传输数据，post通过请求体传输
- get可以缓存、可以保留历史、收藏为书签；post不行
- post数据因为在请求体内，所以有一定的安全性；而get的数据在url中，通过历史记录，缓存很容易查到数据消息。
- get传输数据只允许ASCII字符且有长度限制（最大2048个字符），post无限制
- get后退/刷新无害，post数据会被重新提交（浏览器应该有友好性提示）
- 服务器状态来说：使用get安全（不会引起服务器状态变化）且幂等（同一个请求多次执行效果相同）；post非安全非幂等

### post和put的区别

- put幂等；post非幂等
- put的url指向单一资源，而post可以指向资源集合。
  比如：博客创建一篇文章，用post：`POST https://www.jianshu.com/articles`，语义是，在aticles的资源集合下创建一篇新的文章，如果多次提交请求将会创建多篇文章；而用put：`PUT https://www.jianshu.com/articles/820357430`，语义是，更新对应文章下的资源。

### put和patch的区别

都是更新资源，但是put更新单个目标，patch是对目标局部更新
比如：有文章对象：
`article = {
    author: 'dxy',
    creationDate: '2019-6-12',
    content: '我写文章像蔡徐坤',
    id: 820357430
}`
要更新作者author，用put：
`{
    author:'蔡徐坤',
    creationDate: '2019-6-12',
    content: '我写文章像蔡徐坤',
    id: 820357430
}`
用patch：
`{ author:'蔡徐坤'}`

### 报文

#### 请求报文

- 请求行：请求方法+url+协议版本
- 请求头部：键值对
- 空行
- 请求体：post、put携带的请求数据

#### 响应报文

- 响应行：协议版本+状态码
- 响应头：键值对
- 空行
- 响应体：服务器响应的数据

#### HTTP首部

通用的有：

- Cache-Control 控制缓存
- Connection 连接管理、逐条首部
- Transfor-Encoding 报文主体的传输编码格式

请求首部：

- Accept：客户端能处理的媒体类型
- Accept-Encoding 优先编码格式
- Accept-Chaset 优先可处理的字符集
- if-Match 比较实体标记（ETage）
- if-none-match 与 if-Match相反
- if-Modified-since 比较资源更新时间（last-modified）
- if-unmodified-since 与if-modified-since相反
- range 实体的字体范围
- user-agent 客户端程序信息
- host 请求资源所在服务器

响应首部：

- location 令客户端重定向的url
- etag 能够表示资源唯一资源的字符串
- serve 服务器信息

实体首部 针对请求报文和响应报文的实体部分使用首部

- allow 资源可支持的http方法
- last-modified 资源最后修改的资源
- expires 实体主体的过期资源

### http的keep-alive

http/1.0每次都要创建一个连接，而该过程需要消费资源和时间，于是可以使用请求头connect:keer-alive来告诉对方这个请求响应结束先不用关闭连接，以便于下一次请求。

优点：

- 较少的cpu和内存占用（由于同时打开的连接减少了）
- 允许请求和应答的http管线化
- 降低拥塞控制（TCP减少了）
- 减少了后续请求的延迟

### HTTPS && HTTP2

#### HTTPS的工作原理

非对称加密与对称加密双剑合璧，使用非对称加密算法传递用于对称加密算法的密钥，然后使用对称加密算法进行信息传递。这样既安全又高效

#### HTTPS

- http是超文本传输协议，信息是明文传输，https则是**具有安全性的ssl加密传输协议**。
- http的**连接很简单，是无状态的**；HTTPS协议是由SSL+HTTP协议构建的**可进行加密传输、身份认证的**网络协议，比http协议安全。
- Https协议需要ca证书，**费用较高**。
- https**握手阶段比较费时**，会使页面加载时间延长50%，增加10%~20%的耗电。
- https缓存不如http高效，会**增加数据开销**。

#### 如何保证安全？

[https://www.cxymsg.com/guide/http.html#https%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F](https://www.cxymsg.com/guide/http.html#https是如何保证安全的？)

#### SSL/TLS协议运行机制的概述

> 基本过程：
>
> - 客户端向服务端索要并验证公钥
> - 双方协商生成“对话秘钥”
> - 双方利用公钥给“对话秘钥”加密传输进行通信

http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html
https://cloud.tencent.com/developer/article/1005197

#### http/2.0的特性

- http2.0基本单位为二进制（帧是HTTP/2数据传输的最小单位；流可以承载双向信息，每个流有唯一的ID），基于二进制传输可以让协议有更多扩展性
- **内容安全**，由于http2基于https
- **多路复用**，相当于长连接的增强，1次连接可以让多个request随机混杂在一起，另外还支持了二进制数据优先级，允许客户端告诉服务器哪些资源可以优先传输
- **头部压缩**：可以理解为**只发送差异数据**，而不是全部发送，从而减少头部的信息量
- **服务端推送**：**服务端可以主动推送**js和css等资源，不用等客户端解析html解析到了再请求

### HTTP缓存

#### 过程：

1. 客户端向服务端发出请求，请求资源；
2. 服务端返回资源，并通过响应头决定缓存策略
3. 客户端根据响应头策略决定是否缓存资源（假设是），并将响应头和资源一起缓存
4. 客户端再次请求且命中资源时，客户端检查上次缓存的策略，根据策略不同，是否过期等判断是直接读取本地缓存还是与服务器协商缓存