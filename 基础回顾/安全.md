# Web安全



## 关于Web安全

Web前端开发总是离不开浏览器和网页，而浏览器实际上就是一个客户端软件，如果在这个软件层面上浏览器没有具备安全功能，那么我们就很可能因为访问了某个网页而使计算机收到攻击。

实际上，现在我们基本不会因为浏览网页而导致电脑感染病毒（除非你下载了带病毒的文件），这是因为我们的浏览器具备了安全功能，而这些安全功能恰恰也是Web安全不可分割的一部分，所以在了解Web安全知识之前，先了解主要的浏览器安全。

## 浏览器安全

### 1.同源策略

**同源策略限制了不同源的`document`或脚本对当前`document`的读取或设置某些属性**

同源：协议同+域名同+端口号√

> 共有三种行为受到限制：
>
> 1. Cookie、LocalStorage 和 IndexDB 无法读取。
> 2. DOM 无法获得。（通过frame）
> 3. AJAX 请求不能发送。

 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页**同源**。 

同源策略保证用户信息安全，防止恶意网站窃取数据：设想如果不存在同源限制，意味着用户浏览的任何网站间 Cookie 可以任意互相读取，这样如果 Cookie 包含隐私（如存款总额），就会暴露信息，更可怕的是，如果 Cookie 用来保存用户登录状态（很常用），只要用户没有退出登录，其他网站就可以冒充用户，为所欲为。由于浏览器表单不受同源策略限制， 所以如果同源策略没有限制 Cookie ，那对其他如 ajax 的限制也就没有意义。

### 2. 浏览器沙箱

如果网页代码直接运行在我们电脑的系统进程中，那么网页中的恶意代码就有可能会利用浏览器漏洞执行任意代码对我们的电脑进行攻击。 

 为了对抗“挂马”、“内存攻击”等恶意行为，浏览器发展出了多进程架构和 Sandbox（沙箱），从安全性上有了很大的提高。 

Google Chorme 是第一个采取多进程架构的浏览器，其**进程主要分为：浏览器进程、渲染进程、插件进程、扩展进程**。

**渲染引擎由 Sandbox 隔离**，一**般网页代码要跟浏览器内核、操作系统进行通信都需要通过 IPC channel（进程通道），在其中会进行一些安全检查**。

Sandbox 就是资源隔离模块，其目的一般是让不可信任代码运行在一定环境中，限制不可信任代码访问隔离区外的资源，如果一定要跨越该隔离区产生数据交换，则只能通过指定的数据通道，比如通过封装的API来完成，而这些API中就可以严格检查请求的合法性，提高安全度。
应用到浏览器上，就可以用 Sandbox 让不受信任的网页代码运行在一个受限制的环境内，从而保护本地桌面系统的安全。

![image-20191125221208434](D:\my nutcloud\我的坚果云\typora-user-images\image-20191125221208434.png)

虽然用多进程跟沙箱可以保护浏览器，但第三方插件却不受 Sandbox 限制， 成为浏览器攻击的热点 。

下面是关于 Web 脚本安全领域常见的攻击方式和防范手段。

## Web 脚本安全

### 跨站脚本攻击（XSS）

英文全称是 Cross Site Script，本来缩写是 CSS，但是为了和层叠样式表（Cascading Style Sheet，CSS）有所区别，所以在安全领域叫做`XSS`。 

**通常指黑客发现一个网页的XSS漏洞后通过“HTML注入”的方式插入恶意脚本，当其他用户浏览时，恶意脚本代码就会自动执行，达到攻击目的，如：窃取cookie，破坏页面结构，重定向到其他网站等。**

XSS可以分成如下几类：

#### 反射型

指的是用户输入数据“反射”给浏览器。也就是说，需要黑客诱使用户点击一个经修改的恶意链接才会攻击成功。

比如：

某黑客将一个URL为`http://www.chenzebin.com/xss/reflected/example?param=value`后面的value修改（换成一些恶意代码），然后诱使你点击该链接。由于上例的`value`可能出现在返回的HTML（可能在JS、HTML某元素的内容或属性中）当这个链接打开后，恶意的代码会被HTML解析、执行。

最简单就是`?param=<script>while(true){alert('???')}</script>`
进一步的攻击可能是构造一些提交表单（利用Cookie），已达到修改资料窃取信息等目的。

#### 存储型

指用户的某些操作（发表文章、评论等）可能会保存在服务端，如果这些内容中含有恶意代码，就成了存储型XSS。

比如：

某黑客发表一篇文章（内含恶意js代码），当别的用户访问该文章时，就会顺带执行相应的js恶意代码。

#### DOM Based XSS

指通过修改节点形成的XSS。

比如：

```html
<script>
function test() {
    var str = document.getElementById('text').value;
    document.getElementById('t').innerHTML = "<a href = '" + str + "'>testLink</a>";
}
</script>

<div id="t"></div>
<input type="text" id="text" value="" />
<input type="button" id="s" value="write" onclick="test()" />
```

 点击“write”按钮后，会在当前页面插入一个超链接，其地址为文本框的内容。黑客可以修改该内容肆意操作。

甚至可以通过修改代码闭合掉`<a>`标签，并插入一个新标签，如：

```html
<a href=''><img src=# onerror=alert(/xss2/) /><''> testLink</a>
```

XSS攻击手段太多了， **理论**上，针对HTML、CSS、JavaScript等输入数据做好过滤处理， XSS 漏洞是可以彻底解决的。 

#### 防御手段：

- **浏览器禁止页面的 JS 访问带有 HttpOnly 属性的 Cookie**
- **两端进行输入格式检查**
- **通过编码转义的方式进行输出检查**

### 跨站点请求伪造（CSRF）

![image-20191125231349996](D:\my nutcloud\我的坚果云\typora-user-images\image-20191125231349996.png)

从上图可以看出，要完成一次CSRF攻击，需要受害者完成两个步骤：

1. **登录受信任的网站A，并在本地生成 Cookie 。**
2. **在不登出A的情况下（不解除会话），访问危险网站B**。

事实上，我们很容易达成上述条件，一不小心的成为“受害者”，原因在于：

1. 你很难保证不会再登录一个网站后，再打开一个 tab 页面并访问另外的网站
2. 你不能保证关闭了浏览器后，本地的 Cookie 立刻过期，上次的会话结束（事实上，关闭浏览器不能结束一个会话）
3. 上面的攻击网站，Kenneth更是一个存在其他漏洞的可信任的经常被人访问的网站。

eg：

受信任的银行网站 A ，以GET请求（POST也可）完成转账操作，如：`http://www.bank1.com/Transfer/toBankId=11&money=1000`

危险网站 B ，里面有一段代码为：`  <img src=http://www.bank1.com/Transfer?toBankId=11&money=1000>  `（若是post则通过js执行表单操作）

此时如果你已经登陆了A网站，再访问B，你的浏览器就会带上A网站的 Cookie 去发出请求，结果银行网站服务器收到请求，它虽然不知道是B网站还是浏览器发出的，但是会话 Cookie 没有问题，就许可了本次更新资源操作（这里是转账操作）。

这种攻击模式其实源自于Web的 Cookie 身份验证机制，同个会话的 Cookie 唯一性虽然保证是同一个用户的操作，但无法保证该请求是用户批准发送的。

#### 防范手段：

1. **验证码**

   最常见的方式就是利用要验证码。CSRF攻击时往往是在用户不知情的情况下“偷偷构造网络请求”，而**验证码，就强制用户必须与应用程序进行交互，才能完成最终请求**。

   缺点：降低用户体验。

2. **Anti CSRF Token**

   CSRF之所以能攻击成功，本质原因在于**重要操作的所有参数都是可以被攻击者猜测到的**。

   攻击者只有预测出 URL 的所有参数和参数值，才能成功构造一个伪造的请求，那么只要使用一些随机数，或者把参数加密，不就可以提高安全度了嘛~

   最常见：**在表单中加入一个Token随机值字段**，由于存在同源政策，所以网站B很难获取到 token 来提交表单

   ```html
   <input type="hidden"  name="token" value="ertf52342e21b">
   ```

   或者**使用一些随机数加载参数上，再把参数加密**： 比如，一个删除操作的 URL 是：

   ```js
   url = 'http://www.yangzicong.com/user/delete?username=abc&item=123'
   
   // 把其中的 username 参数改成哈希值：  （需要将随机数也通过cookie（session）一起传给后端以作判断）
   url = 'http://www.yangzicong.com/user/delete?username=md5(salt+abc)&item=123'
   ```

3. **Referer Check**

   Referer Check 在互联网中最常见的应用就是：“防止图片盗链”，例如公众号推文，当我们在其他网站通过iframe引用时，由于 Referer不是公众号页，推文的图片将会被屏蔽。

   同理，Referer Check 也可以用来检查请求是否来自合法的“源”。

   常见的应用：

   一个发博客文章的操作，正常情况下要先登录后，在“发布页”提交发布文章的请求，这时就可以通过判断 Referer的值不是这个页面，甚至不是该网站的域的时候，拦截该请求操作。

   缺点：服务器并非总是能获取 Referer。很多时候处于保护隐私，会限制Referer 的发送。在某些情况下，浏览器也不会发送 Referer，比如从HTTPS的链接跳转到HTTP的链接。

    所以，将 Referer Check 作为防御 CSRF 的主要手段是不可取的。但是通过 Referer Check 来进行辅助判断，倒是可行的方法。 

### 点击劫持（ClickJacking）

简单介绍下点击劫持，点击劫持是 XSS 的引申，所以一般比较少见到，因为大部分网站的 XSS 防御都做得比较好。

点击劫持是一种视觉上的欺骗你手段。攻击者使用一个透明的、不可见的 iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作。当用户点击时，以为点击的是原页面上的按钮，但其实可能恰好点击在 iframe 页面的一些功能性按钮上。

通过不断调整 iframe 内页面元素的位置，或许能让用户完成一系列流程操作。具体是什么操作完全看攻击者的想象力了。

**Flash 也存在点击劫持**，一个比较严重的点击劫持攻击案例是：攻击者通过 Flash 构造出了点击劫持，在完成一系列复杂的动作后，最终控制了用户电脑的摄像头。

案例大概是，攻击者制作了一个 Flash 游戏，这个游戏就是让用户去点击某个小东西，每次点击后这个小东西的位置都会发生变化。通过一步一步的操作，打开了用户的摄像头。

还有很多意想不到的案例，可以自行去了解下，这里不再做介绍。

## HTML5安全

 最后列一下 HTML5 的一些新功能及其会带来的安全问题。 

- 一些 XSS Filter 如果是通过黑名单的方式过滤 XSS 攻击的化，可能不会覆盖到 HTML5 新增的标签和功能。如``标签或``标签，远程加载一段媒体资源，利用某些事件进行脚本攻击。

- HTML5 中``标签和``标签定义的新标签属性`noreferer`，在指定这个属性后，浏览器在请求该标签指定的地址时将不再发送Referer。
- 利用 Canvers 解析图片，在浏览器端自动破解验证码。
- `postMessage`、`Web Storage`读取数据时也要注意对 XSS 的防范。（`window.name`也需要）





> XSS：https://juejin.im/post/5bad9140e51d450e935c6d64#heading-23









